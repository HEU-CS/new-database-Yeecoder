# A1：一个基于内存的分布式的图数据库

各位同学大家好，我要分享的内容是A1: A Distributed In-Memory Graph Database，A1，一个基于内存的分布式图数据库。

## 首先介绍一下A1数据库

### A1是Bing搜索引擎使用的一个内存中的具有完全事务功能的通用的分布式图数据库

用于支持对结构化数据的复杂查询，在处理大规模数据的同时能够保持良好性能和低延迟。

### A1的硬件支持包括DRAM和高速RDMA（远程直接内存访问）网络

RDMA有点类似组成原理里边讲的DMA，只不过把持久化磁盘换成内存了而已。内存存储和RDMA访问的结合就需要考虑在大型分布式系统中如何分配，组织和查询数据。

### A1使用FaRM作为其底层存储层，并在FaRM的上部构建图形抽象和查询引擎

关于FaRM后续会提到。

### A1有自己专属的查询语言A1QL

并且查询语言专注于核心功能，支持的原语足够通用，将查询回归到数据库中而不是应用程序中，比如Facebook的TAO数据存储也是类似的架构，但是它几乎不提供查询功能，而是把查询筛选工作由数据库转移到应用程序。

### A1是延迟优化数据库，系统可用性通过延迟来衡量

如果一个系统的查询有80%延迟是高于延迟预算，那么系统的有效可用性只有80%

## 然后是A1的系统架构

最底层的四层一起构成了一个分布式存储平台，称为FaRM。FaRM提供事务性存储和通用索引结构，而A1的其余部分提供图数据结构和专门的图查询引擎。

## 接下来简单介绍一下FaRM

### FaRM是一种事务型的​​内存分布式计算平台

该平台使用具有RDMA功能的NIC实现将延迟和吞吐量都提高了一个相对于使用TCP/IP的现有内存系统的数量级，这种机制在本机中内存不经过CPU和NIC直接进行通信;与远程机器通信时同样不经过CPU直接远程访问内存;在通信过程中将TCP的可靠性控制,拥塞控制等机制放在NIC和交换机中实现。除此之外FaRM将群集中机器的内存公开为共享地址空间,集群中任何一台机器都可以进行访问。在集群中会选定一台机器指定为管理员对其他设备进行配置和管理，保证了所有操作的一致性，各个机器上的FaRM进程执行分布式事务，这些事务在地址空间中分配，读取，写入和释放对象。FaRM对存储的对象和内容以三种不同的方式进行备份，实现对容错和灾难恢复的支持。

## A1的设计原则

### 指针链接数据结构优化

FaRM中的对象均由指针进行连接，每次解引用指针都需要RDMA读取，为了优化数据结构的布局和位置，尽可能减少指针使用的数量。

### 内存存储优化

内存成本高于SSD，通常A1作为一个快速的可查询存储，比如摘要内容存在A1中，而图片内容存在其他位置。

### 局部性优化

虽然提供了低延迟和高吞吐量，但是访问本地和远程访问必然有时间差存在，所以在创建或查询对象时，在同一台机器上同时定位可能被访问的数据并发送，减少远程读取的次数。

### 并发性优化

由于FaRM事务是在开放式并发性控制下运行的，因此避免单点争用非常关键。对于只读查询，我们使用快照隔离来确保对数据的更新做到这一点。也就是我们查询到的是在那一个时间点上的快照。

### 协作多线程优化

在FaRM进程内部，协作处理器必须使用协作多线程运行，以共享计算资源。

## 接下来是A1的数据结构和查询引擎

在声明顶点类型时，必须将其中一个属性定义为主键，并且主键必须为唯一且非空的，通常每种类型都有一个在主键上定义的排序主索引。边缘类型不需要主键，并且边缘上没有索引。也可以在顶点属性上声明二级索引。对次要索引属性的惟一性或空性没有要求。，

### 目录结构

目录实质上就是键值对，键表示对象的名称，值为指向对象所有数据的指针。

### 顶点和边

顶点分为两个对象：头对象和头数据对象。
边分为三个对象：一个传入链表，一个传出链表，边数据对象。

### 异步流工作

主要用于删除操作，调用DeleteGraph会将图从状态激活转换为删除，但是与图关联的存储和资源不会同步释放。取而代之的是一个异步工作流，它删除所有与图相关的资源，并最终释放图本身在删除图之前，与图关联的所有类型都将被删除。对于要删除的类型，我们删除与该类型关联的所有索引:主索引和辅助索引。当主索引被删除时，我们同时删除顶点。为了确保工作流不干扰实时工作负载，工作线程以较低的优先级运行。

### 查询执行

查询操作传入后端作为协调器并分发查询任务和整合。当一个查询/更新操作到达前端时，默认情况下它会被路由到集群中的一个随机后端机器。查询首先到达的后端机器被指定为查询的协调器，它驱动查询的执行，除此之外大部分查询执行工作分布在集群。每个A1查询都是一个JSON文档，每个层次的嵌套JSON结构描述遍历的一个步骤，起始点位于顶层文档。
如果最终的结果集太大而无法在单个RPC中返回，那么协调器不会返回完整的结果集，而是返回部分结果和一个延续标记。其余的结果缓存在协调器中，客户机可以通过在下一个请求中提供延续令牌来检索这些结果。

## 灾难恢复

### 所有数据以键值对的方式异步存储到ObjectStore

对于每个图，我们在ObjectStore中创建两个表来持久存储数据:顶点表存储所有顶点，而不考虑顶点类型;边表存储所有边。刚刚也提到从A1到ObjectStore的复制是异步的，因此在发生灾难时，ObjectStore可能不包含提交给A1的所有写操作。

### 将数据库恢复为ObjectStore中存在的最新的事务一致性快照

恢复方案支持两种类型的恢复:一致恢复和最佳努力恢复。在一致性恢复中，我们将数据库恢复为ObjectStore中存在的最新的事务一致性快照。使用最佳努力恢复，不能保证A1的恢复状态在事务上是一致的，但是数据库本身在内部是一致的。

### 持续监视复制日志，复制日志采用FIFO的方式对复制进行确认

每一个更新申请都会对应一条复制日志条目，如果复制成功则向客户端确认并删除复制日志里的条目，如果失败就把该日志条目复制到ObjectStore，但没有完成复制的内容在故障时会彻底丢失。

## A1 in Bing

解决了原有知识图谱不能实时更新的问题。能在延迟约束下处理更加复杂的查询，增加了整体系统的灵活性。

只存储可查询数据。A1存储开销很大，所以实体只有可查询的属性存储在A1中，而像图像数据这样的不可查询属性存储在其他地方。

降低了知识服务系统的平均延迟，支持更复杂的查询。

从任何主机或网络故障中快速恢复，同时用户不会察觉到故障的发生。

不透明性和多版本化。A1引入一个全局时钟来解决这两个问题，该时钟为所有事务提供读写时间戳。这些时间戳为所有事务提供了全局序列化顺序。除此之外还实现了多版本并发控制，这确保了只读事务可以与更新事务不冲突地运行。

快速重启防止所有备份FaRM同时故障
将数据和驱动程序中的内存段映射到额外的空间，一旦发生进程崩溃或重新启动，数据和驱动进程的地址空间仍然可用，可以进行快速的恢复。但这种方式不能解决掉电重启和机器崩溃带来的信息丢失。
